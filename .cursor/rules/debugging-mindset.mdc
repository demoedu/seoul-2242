---
alwaysApply: true
description: Debugging Mindset
---

# Debugging Mindset

- 목적: 레포 내 문제 상황에서 일관된 디버깅 절차로 근본 원인(why)을 찾고, 빠르게 복구(how)한다.
- 문제 정의 → 정상 동작 정의 → 최소 재현/관찰 → 차이 원인 탐색 → 가설 수립/검증 → 사후 처리/회고

## 핵심 원칙

- 디버깅은 기술: 재현과 관찰로 증거를 모으고, 가설로 검증한다.
- 원인 파악이 최우선: 해결 전, 왜 발생했는지에 대한 검증 가능한 설명을 확보한다.
- 심적 표상: 정상 동작/문제 패턴/원인-해결 매핑을 지속 갱신한다.

## 단계별 규칙

### 1) 문제 정의 (Define the Problem)

- 현상과 범위를 한 문장으로 고정한다. (무엇이/언제/어디서)
- 사용자/로그/환경 정보를 분리 수집한다. (OS, 브라우저, 빌드, 실험 플래그)
- 다른 문제와 분리한다. (한 번에 한 문제만)

### 2) 정상 동작 정의 (Define Normal Behavior)

- Given/When/Then 형태로 기대 동작을 명문화한다.
- 알려진 도메인 지식과 과거 사례로 보완한다.
- 재현 중 발견된 사실로 수시 갱신한다.

### 3) 최소 재현 + 관찰 (Min Repro & Observe)

- 100% 재현 경로를 만든다. (조건 강제/요소 제거/빈 프로젝트에서 추가)
- 기록한다. (입력, 상태, 로그, 타임라인)
- 재현 불가 시, 정보 수집을 먼저 늘린다. (로그, 텔레메트리, 세션 리플레이)

### 4) 차이의 원인 탐색 (Explore Causes of Difference)

- 정상과 현재의 차이를 구조화해 열거한다. (환경, 입력, 순서, 데이터, 캐시)
- 최소 3개 이상 가설 후보를 적는다. (추상/구체 혼합)
- 막히면 구글링/과거 이슈/Git 이력/동료 설명으로 힌트를 얻는다.

### 5) 가설 설정 및 검증 (Hypothesis & Verification)

- "A라면 B를 B'로 바꿀 때 C가 C'로 바뀐다"로 문장화한다.
- 작은 변경 → 관찰 → 결론을 반복한다. (틀린 가설도 수확)
- 문제가 전이되면 시간을 재설정하고 1단계로 돌아간다.

### 6) 사후 처리 (Post-processing)

- 테스트/로그/모니터링을 업데이트한다.
- 심적 표상(지식 지도)을 갱신하고, 재발 방지 조치를 남긴다.
- 짧은 회고(무엇을 배웠는가, 다음에 무엇을 바꿀 것인가)를 기록한다.

## 권장 도구/습관

- 도구: 브라우저/런타임 디버거, 프로파일러, 로깅, 세션 리플레이, 모니터링.
- 습관: TDD, DDD, IDD(이슈 주도). 도구의 신호는 맹신하지 않는다.

## 산출물 템플릿 (필요 시 활용)

| 항목               | 내용:                   |
| ------------------ | ----------------------- |
| 문제 정의:         | (한 문장)               |
| 정상 동작(각 1줄): | Given / When / Then     |
| 재현 절차:         | (번호 목록)             |
| 관찰 로그:         | (핵심만 요약)           |
| 가설 #1:           | (검증식) → 결과/판정    |
| 가설 #2:           | (검증식) → 결과/판정    |
| 조치:              | (코드/설정/데이터 변경) |
| 사후 처리:         | (테스트/모니터링/문서)  |
| 회고:              | (3줄 이내)              |

## Definition of Done

- 100% 재현 경로와 정상 동작이 문서화되었다.
- 원인에 대한 검증 가능한 설명과 반증 기록이 있다.
- 코드/테스트/문서/관측(로그·알람)이 업데이트되었다.
- 회고 메모가 남았다.
